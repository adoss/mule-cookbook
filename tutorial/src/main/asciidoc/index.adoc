:imagesdir: ./images
:resourcesDir: resources
:tutorial: Mule Cookbook
:author: MuleSoft Inc.
:toc: left
:icons: font
:website: http://mulesoft.org/
:muleJerveyVersion: 2.11
:toclevels: 1
:title: Cookbook Tutorial - MuleSoft

= Anypoint Studio Devkit

include::introduction.adoc[]

include::requirements.adoc[]

include::installPlugin.adoc[]

= Build Your Connector

== What is a Connector

A @Connector is a reusable component that knows how to interact with Mule, and with Anypoint Studio. 

From the developer point of view, it abstracts them from Mule interfaces required run in the platform, and the generation of the UI.

For the users, it abstracts them from the complexity of initializing any required element (connecting to a sandbox for example). A well developed connector makes your Mule apps much more simple by handling internally things like pagination, session expirations or input and output meta data. 

For a quick overview of the Anypoint Studio DevKit Plugin and how to create a basic Connector check the documentation.

include::features-covered.adoc[]

include::service-description.adoc[]

== Building a Connector

Before start consuming our {tutorial} service, lets start by doing a Hello World Connector, and understanding the generated code.

. Click *File* > *New*, then select *Anypoint Connector Project* or simple do a right click of the package explorer and select *New* > *Anypoint Connector Project*:
+
image::new-connector-1.png[width="500"]
+
. Just put the name of your connector and click on finish:
+
image::new-connector-2.png[width="500"]
+
This generates a project containing the structure with all the required elements such as images, sample docs, and some basic tests for your connector.
+
image::new-connector-3.png[width="600"]
+
. To enable the DevKit view select from the top bar *Window* > *Show view* > *Other* , and look for DevKit on the list.
+
image::enable-view.png[width="300", height="400"]

=== Understanding the a Connector Structure

Your Connector basically consists of a set of http://www.mulesoft.org/documentation/display/current/Message+Processors[message processors] and configurable elements users populate in order to consume the API your connector was developed for.

After you install your connector by right-clicking the connector and clicking *Anypoint Connector* > *Install or Update*, completing the prompts, and restarting Studio, you will be able to properly open the Mule application that is being used in the connector test that was generated for your connector.

Lets check the structure of this dummy connector:

In this image you will be able to see how most of the code is mapped into UI elements.

// TODO: Use 2 images of screenshots with the default layout

image::split-1-high.png[caption="Figure 1: ", title="View Structure and UI", alt="Image1", width="500", height="200", link="images/split-1-high.png"]

In this one, you can check how the code matches to XML and other UI elements.

// TODO: Use 2 images of screenshots with the default layout

image::split-2-high.png[caption="Figure 2: ", title="View configuration and XML", alt="Image2", width="500", height="200", link="images/split-2-high.png"]

=== Connecting to my service

When consuming a service there you may need to configure different values in order to establish a connection. 

To solve this, the DevKit provides a pair of annotations that allows developer to modularize in one class the behaviour exposed to the users (using the @Connector annotation) and in a different one the code related to the connection.

By marking a field with @ConnectionStrategy the DevKit will make sure that you have an initialized object set when the Mule app is running and a request is made to your connector.

At this point there is no need for authentication and/or connection management but you need to configure some things, so we will create a class marked with @Configuration.

If you actually need an authentication there are several annotations that will help you achieve the desired behaviour as we will see in this tutorial.

To go deeper into this feature, check the http://www.mulesoft.org/documentation/display/current/Authentication[current documentation].

Let start coding and create a connector that allows us to get the recently added elements.

Since the {tutorial} service description says we don't need any kind of authentication to consume the recently added recipies, this is the best operation we can use to start learning how to build our @Connector.

. Create a new Anypoint Connector Project with the following configuration and don't forget to uncheck the default generation:
+
image:new1.png[width="500"]
+
After that lets add our client dependency so that we can use it in our connector.
+
. In your pom.xml add:
+
[source,xml,indent=0]
----
<dependencies>
  <dependency>
    <groupId>org.mule.tools.devkit.cookbook</groupId>
    <artifactId>sdk-client</artifactId>
    <version>1.0.0</version>
  </dependency>
</dependencies>
----

==== Initialize the Connector

We need to initialize the client before consuming the service.

Anypoint Connectors can be fully aware of http://www.mulesoft.org/documentation/display/34X/Integrating+Connectors+with+the+Mule+Lifecycle[Mule's lifecycle] without implementing any Mule specific interface.

. Use the @Start to initialize our client.
+
[source,java]
----
include::{resourcesDir}/java/v1/CookBookConnector.java[lines=30..35]
----
Check the full link:{resourcesDir}/java/v1/CookBookConnector.java[source code] to where @Start fits in.

If you want, you can continue and directly implement your connector with connection management, if not, just go to the add your first <<configurable,configurable>>.

==== Using Connection Management

Almost all requests  requires that we sent a token on each request.

The client we are using provides a login call that will initialize the token and use it in subsequent requests.

But now also, we have to take into account that our session could expire, and we will need to make a login request again.

DevKit provides a different set of annotations that will help us keep our code clean, and handle the connection in a different class delegating responsibilities.

We are going to implement a @ConnectionManagement.

Instead of using the @Start annotation as we did before, we will move the initialization to this @ConnectionManagement.

We need to implement 4 methods:

* *@Connect:* Here you need to initialize the client, and also if you don't have a login, you should make a call to the API to verify
* *@Disconnect:* Release any connection if required.
* *@ValidateConnection:* This method should check your connection is alive.
* *@ConnectionIdentifier:* This method just return a dummy value currently.

After our @Connector looks like this:

[source,java,indent=0]
----
include::{resourcesDir}/java/v2/CookBookConnector.java[]
----

And our @ConnectionStrategy like this:
[source,java,indent=0]
----
include::{resourcesDir}/java/v2/ConnectorConnectionStrategy.java[]
----

But if we try to run our tests, now we will see that the test while fail with a SAXParseException. because we need to add username and password to our configuration now.

===== Testing Connection is Working

Testing our connection management needs for us to do some low level coding, but is it still clear how to do it.

We will use the mule context and the registry to get our hands in our config elements, wrapper in a Testable Object, so that we can run our @Connect method.

In our mule app, we just need to add a configuration that has bad credentials.

The we just execute the test and make the assertions.

image::connectivityTest.png[width="600"]

==== Using OAuthV2

// TODO: Sample with OAuthV2

Use v1 to show how to implement OAuthV2 in your connector
[[configurable]]
=== Adding configurable fields

Adding configurable fields is also easy with the plugin since there are a couple of templates ready for you to use.

Just type "conf" at the editor of your @Connector or your connection strategy and use Ctrl + Space bar to display the templates.

image::config1.png[width="600"]

In our case, lets at a configurable field in our @Configuration component with a default value for the endpoint our client will connect to.

This way we will allow users to connect to different sandboxes.

image::config2.png[width="600"]

We are now ready to add our first processor. If you want a little more details about configurable fields, continue reading. If not, lets just go to add our <<processor,processor>>.

==== @Optional

Optional parameters or configurable ones, as the name states, are elements that are not required, and there for, there is no need for users to specify a value.

Configurable fields can be specified inside @Connector or Connection Strategies Classes, or as parameters of @Processor methods inside a @Connector.

[source,java]
----
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.param.Optional;

//Inside the @Connector class

/**
 * Optional Field documentation
 */
@Configurable
@Optional
private String  optionalField;
//Getter and Setter of the field are required

/**
 * Optional parameter
 */
public String sayHi(String firstName,@Optional String lastName ) {
    return "Hi "+firstName+" "+((lastName==null) ? "":lastName);
}
----

==== @Default

When you want an optional parameter or configurable you can avoid the use of @Optional and just use the @Default annotation.
[source,java]
----
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.param.Default;

//Inside the @Connector class

/**
 *  Field with Default
 */
@Configurable
@Default("Hi")
private String  greeting;
//Getter and Setter of the field are required

/**
 * Default parameter
 */
public String sayHi(String firstName,@Default("Unknown") String lastName ) {
    return greeting+" "+firstName+" "+lastName;
}
----

Another very important use of the @Default annotation is when building a connector that has DataSense.
[[processor]]
=== Adding operations to my @Connector (@Processor)

To add a processor simply type "proc" at the editor and use Ctrl + Space bar to display the templates and pick the simple processor.

image::processor1.png[width="600"]

Lets change it to reflect the getRecentlyAdded method signature, and there we have..our first connector, ready to be tested.

image::processor2.png[width="600"]

==== Adding samples to your connector

Lets now add the example for it.

First create the file pointed by the *{@sample ...}*

NOTE: When you add an example, the name provided here is the name that narrows the example in the file. Inside of it you have to put an example of the @Processor.

If you have the Javadoc check enabled, DevKit plugin will mark the missing example as an error and provide a quick fix for us to easily add the example.

Otherwise, open the file and type "<" at the editor and use Ctrl + Space bar to display the templates and pick the one that best suite our operation.

image::sample1.png[width="600"]

Our example in this case looks like this:

[source,xml,indent=0]
----
<!-- BEGIN_INCLUDE(cook-book:getRecentlyAdded) -->
	<cook-book:get-recently-added/>
<!-- END_INCLUDE(cook-book:getRecentlyAdded) -->
----

=== Testing your @Processor

In order to test our @Processor, lets start by generating the required files for us to test the operation, as if it was being used inside a mule application.

Right click the root of your project and select *Anypoint Connector > Generate Tests*.

Select the operation you want to use to generate the test, and all the files you want to create.

After the generation ends, just modify the test to make the corresponding setup and assertions.

image::generate-tests1.png[width="600"]

Start the server, and run your test now.

It is all green!

image::generate-tests2.png[width="600"]

So..what just happened?

* We run a mule app that contains one simple flow with the xml that represents our operation.
* A connector instance was created and using our configuration, it connected to the server.
* The operation was executed and the payload now is the result of that operation
* We retrieve the payload, cast it to what we know the result is and started making the relevant assertions.

See:

* Adding http://mulesoft.github.io/connector-certification-docs/current/user-manual.html#functional_tests_automation[Functional Tests Automation].

* http://mulesoft.github.io/connector-certification-docs/current/user-manual.html#_generating_functional_tests[Generating Functional Tests].


include::errorHandling.adoc[]

include::datasense.adoc[]

include::pagination.adoc[]

include::batch.adoc[]

include::install-connector.adoc[]

include::debug.adoc[]

include::documenting.adoc[]

== Sharing my @Connector

Connector, as a component that can be installed in Anypoint Studio, is an Update Site.

Update Sites are used to organize and export features so they can be installed into Eclipse applications.

When the site is built, the included features (along with all plug-ins part of those features) will be exported into an installable form. The exported plug-ins and features will be put into two folders "plug-ins" and "features". Two other files, "content.xml" and "artifacts.xml" will also be generated and contain metadata for the exported files that make installing easier. These files, along with "site.xml", collectively form an Eclipse update site. To make the update site available to others you must make all these files available in a shared directory or web site.

When building a connector, DevKit generates this for you, so that you don't need to worry about generating this. 

You can use the Anypoint DevKit plugin to either install the connector on your current Studio, or export it as an update-site for others to use.

== Other Features

include::source.adoc[]

include::transformer.adoc[]

=== Improve UI Layout

==== Using friendlyName

// TODO

Show how to change the display name of the @Connector

==== Using @Password

When using the @Password in a @Connect parameters, you will generate in the UI a masked input field.

[source,java]
----
include::{resourcesDir}/java/v2/ConnectorConnectionStrategy.java[lines=50..53]
----

In Studio this is translated into:

image::password.png[width="500"]

==== Using @Placement

//TODO

== I have an API to build the @Connector

API are exposed in several ways, and in order to start using it you need to do setup different things before using it inside your connector.

=== SDK Client

If you have an SDK all you need to do is to include the Maven dependency for your jar in the pom.xml

For example in our case, to consume the SDK for the Cookbook we can add the dependency.

[source,xml,indent=0]
----
<dependencies>
  <dependency>
    <groupId>foo.sdk.group.id</groupId>
    <artifactId>foo.sdk.artifact.id</artifactId>
    <version>${sdk.version}</version>
  </dependency>
</dependencies>
----

=== SOAP API

If you have a wsdl, the easiest way to build a connector is to create a client using cxf http://cxf.apache.org/docs/wsdl-to-java.html[wsdl2java].

You can configure the cxf goal in your pom.xml, very easily. The full documentation can by founded at http://cxf.apache.org/docs/maven-cxf-codegen-plugin-wsdl-to-java.html[cxf site].

For example in your pom.xml you can add this (plus all the dependencies required) :
[source,xml,indent=0]
----
<build>
  <plugins>
    <!-- CXF Code generation -->
    <plugin>
      <groupId>org.apache.cxf</groupId>
      <artifactId>cxf-codegen-plugin</artifactId>
      <version>${cxf.version}</version>
      <executions>
        <execution>
          <phase>clean</phase> <!-- This is so it work with the Devkit -->
          <goals>
            <goal>wsdl2java</goal>
          </goals>
          <configuration>
            <wsdlOptions>
              <wsdlOption>
                <wsdl>${basedir}/src/main/resources/wsdl/IMuleCookBookService.wsdl</wsdl>
                <autoNameResolution>true</autoNameResolution>
                <extendedSoapHeaders>false</extendedSoapHeaders>
                <extraargs>
                  <extraarg>-xjc-Xbg</extraarg>
                   <extraarg>-xjc-Xcollection-setter-injector</extraarg>
                  <extraarg>-p</extraarg>
                  <extraarg>org.mule.modules.wsdl.api</extraarg>
                </extraargs>
              </wsdlOption>
            </wsdlOptions>
          </configuration>
         </execution>
      </executions>
      <dependencies>
        <!-- Boolean getters -->
        <dependency>
          <groupId>org.apache.cxf.xjcplugins</groupId>
          <artifactId>cxf-xjc-boolean</artifactId>
          <version>${cxf.version.boolean}</version>
        </dependency>
        <!-- Collection Setters -->
        <dependency>
          <groupId>net.java.dev.vcc.thirdparty</groupId>
          <artifactId>collection-setter-injector</artifactId>
          <version>0.5.0-1</version>
        </dependency>
      </dependencies>
    </plugin>
  </plugins>
</build>
----

If you use the DevKit plugin it will generate everything for you to get started, you just need to specify the wsdl location.

=== REST API
In this case, you have to write the request using any library that helps you make HTTP Requests.

We recommend using Jersey {muleJerveyVersion} since it is the one provided by mule (since 3.6.0).
[source,xml,indent=0]
----
<dependencies>
  <dependency>
    <groupId>org.glassfish.jersey.core</groupId>
    <artifactId>jersey-client</artifactId>
    <version>{muleJerveyVersion}</version>
    <scope>provided</scope>
  </dependency>
</dependencies>
----

To make for example a GET Request you can do the following:
[source,java,indent=0]
----
ClientConfig clientConfig = new ClientConfig();
Client client = ClientBuilder.newClient(clientConfig);
WebTarget webTarget = client.target("http://example.com/rest");  // # <1>
WebTarget resourceWebTarget = webTarget.path("resource");
WebTarget helloworldWebTarget = resourceWebTarget.path("helloworld");  // # <2>
WebTarget helloworldWebTargetWithQueryParam =
        helloworldWebTarget.queryParam("greeting", "Hi World!");  // # <3>

Invocation.Builder invocationBuilder =
        helloworldWebTargetWithQueryParam.request(MediaType.APPLICATION_JSON_TYPE);  // # <4>

Response response = invocationBuilder.get();  // # <5>
System.out.println(response.getStatus());
System.out.println(response.readEntity(String.class));
----
<1> - At this point we have a client ready to make a request to URL http://example.com/rest
<2> - We add some paths. It looks like http://example.com/rest/resource/helloworld
<3> - We configure a query param. It looks like http://example.com/rest/resource/helloworld?greeting=Hi+World%21
<4> - We specify we want the reply in JSON format
<5> - We make a GET request


If you want more information visit the https://jersey.java.net/documentation/latest/client.html[jersey client] documentation.
