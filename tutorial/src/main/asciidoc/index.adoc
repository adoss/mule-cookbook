:doctype: book
:imagesdir: ./images
:resourcesDir: resources
:tutorial: Cookbook
:author: MuleSoft Inc.
:toc: left
:icons: font
:website: http://mulesoft.org/
:muleJerveyVersion: 2.11
:toclevels: 2
:title: Cookbook Tutorial - MuleSoft

= Cookbook Tutorial

include::introduction.adoc[]

include::requirements.adoc[]

== What is a Connector?

A MuleSoft connector is a reusable component that interacts with the Mule ESB and  Anypoint Studio. A connector enables Mule flows to communicate with a target resource. The connector conveys data between a resource and a Mule flow, and transforms the data into a Mule Message.

Using Anypoint Connector DevKit, a connector abstracts developers from the Mule interfaces required to run the connector in the Mule platform, and handles the generation of a user interface.

A connector also abstracts users from the complexity of initializing required elements such as connecting to a sandbox. A well-developed connector makes Mule apps much simpler by handling internal tasks like pagination, session expirations, or input and output metadata. This tutorial shows you how to create a well-developed connector.

For a quick overview of the Anypoint Studio DevKit Plugin and how to create a basic Connector, see http://www.mulesoft.org/documentation/display/current/Setting+Up+Your+Dev+Environment[Setting up Your Dev Environment] and  http://www.mulesoft.org/documentation/display/current/Anypoint+Connector+DevKit[Anypoint Connector DevKit].

include::features-covered.adoc[]

include::service-description.adoc[]

== Building a Connector

Before starting our {tutorial} service, let's start by creating a Hello World Connector, and reviewing its generated code.

To create the Hello World connector:

. In Anypoint Studio, click *File* > *New* > *Anypoint Connector Project* or right-click your project name in package explorer and click *New* > *Anypoint Connector Project*:
+
image::new-connector-1.png[width="500"]
+
. Specify the name of your connector and click *Finish*:
+
image::new-connector-2.png[width="500"]
+
This generates a project containing the structure and all required elements such as images, sample docs, and basic tests for your connector.
+
image::new-connector-3.png[width="800"]
+
. Enable the DevKit view by clicking from the top bar *Window* > *Show view* > *Other*, and look for DevKit on the list.
+
image::enable-view.png[width="300", height="400"]


=== Connector Structure

Your connector initially consists of a set of message processors and configurable elements that users populate in Anypoint Studio to consume the API your connector was developed for.

The DevKit makes it easy to install a connector in Studio. After you install your connector in Studio, users can search for the connector and drag it into a Mule flow.

Installing only requires right-clicking the name of the connector in Studio's Package Explorer, and clicking *Anypoint Connector* > *Install or Update*, completing the prompts, and restarting Studio.

When you first create your connector using *File* > *New* > *Anypoint Connector Project*, DevKit creates a skeleton connector.

Let's check the structure of this skeleton connector.

In this image you can see how most of the code maps into UI elements.

// TODO: Use 2 images of screenshots with the default layout

image::split-1-high.png[caption="Figure 1: ", title="View Structure and UI", alt="Image1", width="800", link="images/split-1-high.png"]

In this example, you can check how the code matches to XML and other UI elements.

// TODO: Use 2 images of screenshots with the default layout

image::split-2-high.png[caption="Figure 2: ", title="View configuration and XML", alt="Image2", width="800", link="images/split-2-high.png"]

=== Connecting to a Service

When consuming a service, you may need to configure different values to establish a connection.

To solve this, the DevKit provides a pair of annotations that let you
modularize in different classes the behavior you expose to users, using the @Connector annotation, and in a different class the code related to the connection using @ConnectionStrategy.

When you mark a field with @ConnectionStrategy, DevKit ensures that you have an initialized object set when the Mule app runs and that requests are made to your connector.

If there is no need for authentication and/or connection management, but you need users to configure parameters, mark your class with @Configuration.

If you need authentication, other annotations in this tutorial help you achieve this behavior.

For more information, see  http://www.mulesoft.org/documentation/display/current/Authentication[Authentication].

Let's start coding and create a connector that allows you to get the recently added elements.

Since the {tutorial} service description says we don't need any kind of authentication to consume the recently added recipes, this is the best operation we can use to start learning how to build our @Connector.

. Create a new Anypoint Connector Project with the following configuration and don't forget to uncheck the default generation:
+
image:new1.png[width="700"]
+
Add our client dependency so that we can use it in our connector.
+
In your pom.xml add:
+
[source,xml,indent=0]
----
<dependencies>
  <dependency>
    <groupId>org.mule.tools.devkit.cookbook</groupId>
    <artifactId>sdk-client</artifactId>
    <version>1.0.0</version>
  </dependency>
</dependencies>
----

==== Initializing the Client Without Authentication

While we don't need to authenticate against our sandbox, we still need to initialize the client before consuming the service.

Anypoint connectors can be fully aware of Mule's lifecycle without implementing any Mule-specific interface. There is an annotation method for each of the four phases of Mule lifecycle. When a method is annotated with one of these annotations, DevKit invokes the method during the Mule lifecycle phase that the annotation represents.

To initialize a client:

. Use @Start to initialize our client.
+
[source,java]
----
include::{resourcesDir}/java/v1/CookBookConnector.java[lines=30..35]
----
+
. Check the full link:{resourcesDir}/java/v1/CookBookConnector.java[source code].

If you want, you can continue and directly implement your connector with connection management, if not, go to the add your first <<configurable,configurable>>.

==== Using Connection Management

Unlike the *getRecentlyAdded* call that doesn't need for us to be authenticated, all other operations require that you set a token on each request.

The client we are using provides a login call that initializes the token and uses it in subsequent requests.

*Note*: Take into account that our session can expire and cause us to make a login request again.

DevKit provides a different set of annotations to keep our code clean and handle the connection in a different class for delegating responsibilities.

To implement @ConnectionManagement:

. Instead of using the @Start annotation as we did before, we move the initialization to  @ConnectionManagement.
. Implement these four methods:
+
* *@Connect* - Initialize the client, and if you don't have a login, call the API to verify.
* *@Disconnect* - Release any connection if required.
* *@ValidateConnection* - Check that your connection is alive.
* *@ConnectionIdentifier* - Return a dummy value currently.
+
Our @Connector now looks like:
+
[source,java,indent=0]
----
include::{resourcesDir}/java/v2/CookBookConnector.java[]
----
+
Our @ConnectionStrategy is:
+
[source,java,indent=0]
----
include::{resourcesDir}/java/v2/ConnectorConnectionStrategy.java[]
----

If we try to run our tests, now we see that the test fails with a SAXParseException because we need to add a username and password to our configuration.

===== Testing That a Connection Works

Testing our connection management requires low level coding.

We use the Mule context and the registry to work with our config elements, and create a wrapper in a Testable Object, so that we can run our @Connect method.

In our Mule app, we just need to add a configuration that has bad credentials.

Then we execute the test and make the assertions.

image::connectivityTest.png[width="600"]

==== Using OAuthV2

// TODO: Sample with OAuthV2

Use v1 to show how to implement OAuthV2 in your connector
[[configurable]]

=== Adding Configurable Fields

Adding configurable fields is also easy with the plugin since DevKit provides templates ready for you to use.

In Studio, type *conf* at the editor of your connector or your connection strategy and use Ctrl+Space to display the templates.

image::config1.png[width="600"]

Let's add a configurable field in our @Configuration component with a default value for the endpoint our client connects to so that users can connect to different sandboxes.

image::config2.png[width="600"]

We are now ready to add our first processor. If you want more details about configurable fields, continue reading. If not, go to add our <<processor,processor>>.

==== @Optional Method

Optional parameters or configurable ones are elements that are not required, and therefore, there is no need for users to specify a value.

You can specify configurable fields inside an @Connector or connection strategies classes, or as parameters of @Processor methods inside a @Connector.

[source,java]
----
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.param.Optional;

//Inside the @Connector class

/**
 * Optional Field documentation
 */
@Configurable
@Optional
private String  optionalField;
//Getter and Setter of the field are required

/**
 * Optional parameter
 */
public String sayHi(String firstName,@Optional String lastName ) {
    return "Hi "+firstName+" "+((lastName==null) ? "":lastName);
}
----

==== @Default

When you want an optional parameter or configurable you can avoid the use of @Optional and just use the @Default annotation.
[source,java]
----
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.param.Default;

//Inside the @Connector class

/**
 *  Field with Default
 */
@Configurable
@Default("Hi")
private String  greeting;
//Getter and Setter of the field are required

/**
 * Default parameter
 */
public String sayHi(String firstName,@Default("Unknown") String lastName ) {
    return greeting+" "+firstName+" "+lastName;
}
----

Another very important use of the @Default annotation is when building a connector that has DataSense.
[[processor]]

=== Adding Operations to an @Connector (@Processor)

To add a processor simply type *proc* at the editor and use Ctrl+Space to display the templates and pick the simple processor.

image::processor1.png[width="600"]

Let's change it to reflect the +getRecentlyAdded+ method signature, and there we have our first connector, ready to be tested.

image::processor2.png[width="600"]

==== Adding Samples to Your Connector

Let's now add the example for it.

First create the file pointed by the *{@sample ...}*

*Note*: When you add an example, use the same name as the name that narrows the example in the file. Inside of it you have to put an example of the @Processor.

If you have the Javadoc check enabled, DevKit plugin marks the missing example as an error and provide a quick fix for us to easily add the example.

Otherwise, open the file and type *<* at the editor and use Ctrl+Space to display the templates and pick the one that best suite our operation.

image::sample1.png[width="600"]

Our example in this case looks like this:

[source,xml,indent=0]
----
<!-- BEGIN_INCLUDE(cook-book:getRecentlyAdded) -->
	<cook-book:get-recently-added/>
<!-- END_INCLUDE(cook-book:getRecentlyAdded) -->
----

=== Testing your @Processor

To test your @Processor, let's start by generating the required files for us to test the operation, as if it was being used inside a Mule application.

Right click the root of your project and select *Anypoint Connector > Generate Tests*.

Select the operation you want to use to generate the test, and all the files you want to create.

After the generation ends, just modify the test to make the corresponding setup and assertions.

image::generate-tests1.png[width="600"]

Start the server, and run your test now.

It is all green!

image::generate-tests2.png[width="600"]

So..what just happened?

* We run a Mule app that contains one simple flow with the xml that represents our operation.
* A connector instance was created and using our configuration, it connected to the server.
* The operation was executed and the payload now is the result of that operation
* We retrieve the payload, cast it to what we know the result is and started making the relevant assertions.

To go deeper into our testing best practices please read the full http://www.mulesoft.org/documentation/display/current/Developing+DevKit+Connector+Tests[testing documentation].

include::errorHandling.adoc[]

include::datasense.adoc[]

include::pagination.adoc[]

include::batch.adoc[]

include::install-connector.adoc[]

include::debug.adoc[]

include::documenting.adoc[]

== Sharing My @Connector

Connector, as a component that can be installed in Anypoint Studio, is an Update Site.

Update Sites are used to organize and export features so they can be installed into Eclipse applications.

When the site is built, the included features (along with all plug-ins part of those features) will be exported into an installable form. The exported plug-ins and features will be put into two folders "plug-ins" and "features". Two other files, "content.xml" and "artifacts.xml" will also be generated and contain metadata for the exported files that make installing easier. These files, along with "site.xml", collectively form an Eclipse update site. To make the update site available to others you must make all these files available in a shared directory or web site.

When building a connector, DevKit generates this for you, so that you don't need to worry about generating this.

You can use the Anypoint DevKit plugin to either install the connector on your current Studio, or export it as an update-site for others to use.

== Other Features

include::source.adoc[]

include::transformer.adoc[]

=== Improve UI Layout

==== Using friendlyName

// TODO

Show how to change the display name of the @Connector

==== Using @Password

When using the @Password in a @Connect parameters, generate in the UI a masked input field.

[source,java]
----
include::{resourcesDir}/java/v2/ConnectorConnectionStrategy.java[lines=50..53]
----

In Studio this translates into:

image::password.png[width="500"]

==== Using @Placement

//TODO

== I Have an API to Build My Connector

APIs are exposed in several ways. To start using your API, set up different things before using it inside your connector.

=== SDK Client

If you have an SDK all you need to do is to include the Maven dependency for your jar in the pom.xml

For example in our case, to consume the SDK for the Cookbook we can add the dependency.

[source,xml,indent=0]
----
<dependencies>
  <dependency>
    <groupId>foo.sdk.group.id</groupId>
    <artifactId>foo.sdk.artifact.id</artifactId>
    <version>${sdk.version}</version>
  </dependency>
</dependencies>
----

=== SOAP API

If you have a wsdl, the easiest way to build a connector is to create a client using cxf http://cxf.apache.org/docs/wsdl-to-java.html[wsdl2java].

You can configure the CXF goal in your pom.xml file very easily. The full documentation is at the Apache  http://cxf.apache.org/docs/maven-cxf-codegen-plugin-wsdl-to-java.html[CXF site].

For example in your pom.xml file, you can add the following plus all required dependencies:
[source,xml,indent=0]
----
<build>
  <plugins>
    <!-- CXF Code generation -->
    <plugin>
      <groupId>org.apache.cxf</groupId>
      <artifactId>cxf-codegen-plugin</artifactId>
      <version>${cxf.version}</version>
      <executions>
        <execution>
          <phase>clean</phase> <!-- This is so it work with the DevKit -->
          <goals>
            <goal>wsdl2java</goal>
          </goals>
          <configuration>
            <wsdlOptions>
              <wsdlOption>
                <wsdl>${basedir}/src/main/resources/wsdl/IMuleCookBookService.wsdl</wsdl>
                <autoNameResolution>true</autoNameResolution>
                <extendedSoapHeaders>false</extendedSoapHeaders>
                <extraargs>
                  <extraarg>-xjc-Xbg</extraarg>
                   <extraarg>-xjc-Xcollection-setter-injector</extraarg>
                  <extraarg>-p</extraarg>
                  <extraarg>org.mule.modules.wsdl.api</extraarg>
                </extraargs>
              </wsdlOption>
            </wsdlOptions>
          </configuration>
         </execution>
      </executions>
      <dependencies>
        <!-- Boolean Getters -->
        <dependency>
          <groupId>org.apache.cxf.xjcplugins</groupId>
          <artifactId>cxf-xjc-boolean</artifactId>
          <version>${cxf.version.boolean}</version>
        </dependency>
        <!-- Collection Setters -->
        <dependency>
          <groupId>net.java.dev.vcc.thirdparty</groupId>
          <artifactId>collection-setter-injector</artifactId>
          <version>0.5.0-1</version>
        </dependency>
      </dependencies>
    </plugin>
  </plugins>
</build>
----

If you use the DevKit plugin it generates everything for you to get started, you just need to specify the WSDL location on your computer.

=== REST API
Write the request using any library that helps you make HTTP Requests.

We recommend using Jersey {muleJerveyVersion}, which is provided in Mule version 3.6.0 and later.
[source,xml,indent=0]
----
<dependencies>
  <dependency>
    <groupId>org.glassfish.jersey.core</groupId>
    <artifactId>jersey-client</artifactId>
    <version>{muleJerveyVersion}</version>
    <scope>provided</scope>
  </dependency>
</dependencies>
----

Example GET request:
[source,java,indent=0]
----
ClientConfig clientConfig = new ClientConfig();
Client client = ClientBuilder.newClient(clientConfig);
WebTarget webTarget = client.target("http://example.com/rest");  // # <1>
WebTarget resourceWebTarget = webTarget.path("resource");
WebTarget helloworldWebTarget = resourceWebTarget.path("helloworld");  // # <2>
WebTarget helloworldWebTargetWithQueryParam =
        helloworldWebTarget.queryParam("greeting", "Hi World!");  // # <3>

Invocation.Builder invocationBuilder =
        helloworldWebTargetWithQueryParam.request(MediaType.APPLICATION_JSON_TYPE);  // # <4>

Response response = invocationBuilder.get();  // # <5>
System.out.println(response.getStatus());
System.out.println(response.readEntity(String.class));
----
<1> - The client is ready to make a request to URL http://example.com/rest
<2> - Add paths for http://example.com/rest/resource/helloworld
<3> - Configure a query param. It looks like http://example.com/rest/resource/helloworld?greeting=Hi+World%21
<4> - Specify we want the reply in JSON format
<5> - Make a GET request


For more information, see the https://jersey.java.net/documentation/latest/client.html[Jersey client] documentation.
