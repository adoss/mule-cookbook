:mule: Mule Cookbook

== Adding DataSense

=== What is it?

http://www.mulesoft.org/documentation/display/current/DataSense[DataSense] is a feature used to improve the user experience at design time when creating Mule applications.

If coded correctly, user will be able to take advantage of the messages metadata to facilitate application design. With this functionality, Anypoint(TM) Studio proactively acquires information about data, such as data type and structure, in order to prescribe how to accurately map or use data in your application.

Is feature that displays the metadata of the entities included in the service in a friendly manner. Although this feature is optional, Mule strongly recommends that you use DataSense in your connector much easier to use for end users.

Full documentation is available http://www.mulesoft.org/documentation/display/current/Adding+DataSense[here].

=== How to implement it

==== My model is static

When we say that a model is static, it mean that the entities are fixed and know and cannot change in anyway. The fields it supports are fixed.

Lets analyze the entities in {mule} service. We just have 2 simple entities, Recipe and Ingredient that extends from CookBookEntity.

Now, lets take a look at how our createIngredient operation looks inside Anypoint Studio. And how it interacts with other components.

[source,java,indent=0]
----
include::{resourcesDir}/java/v3/CookBookConnector.java[lines=66..70]
----

We defined the operation so that it receives an Ingredient, and it return the Ingredient with the extra fields populated form the server.

If we check the input metadata, we can see that the expected output is a Pojo, with the expected fields our Ingredient has:

image::datasense.png[width="900"]

If we verify the output metadata, it is also the expected one.

image::datasense2.png[width="900"]

So now, if we drag and drop a datamapper either behind or after our connector, we will see that datamapper automatically picks the input or output.

image::datamapper-input1.png[title="Datamapper Receiving Connector Output ", width="900"]

image::datamapper-output1.png[title="Datamapper Setting Connector Input",width="900"]

Because DevKit auto generates static meta data, your connector know how propagate meta data information.

But we don't have just Ingredients, we also have Recipes, but we don't want to have one method for each entity we have in our model.

So lets make some modifications so that we just work with the CookBookEntity class.

Here we have our new create operation.
[source,java,indent=0]
----
include::{resourcesDir}/java/v4/CookBookConnector.java[lines=67..72]
----

Because of some DevKit limitations regarding how to handle Abstract classes, we need to specify that the input can only be specified as a reference.

But lets see how this affects the UI and user experience.

Studio, can no longer determine input or output type:

image::ref-only-input.png[title="Connector Input with @RefOnly",width="900"]

image::ref-only-output.png[title="Connector Output with Abstract Class",width="900"]

And even in datamapper is not automatically populated, with the type:

image::ref-only-datamapper.png[title="Datamapper with connector with @RefOnly parameter",width="900"]

We are forced to manually configure the input:

image::manual-datamapper.png[title="Selecting the pojo manually",width="900"]

In the next section we will see how me can get back our datamapper friendly user experience.

==== Implementing adding @MetaDataCategory

In order to implement DataSense using a @MetaDataCategory you need to separate your implementation in 2 steps, retrieving the keys and then describing the keys.

First, we will annotate our retriever with the @MetaDataCategory and inject the connector (this last one is a requirement in the current devkit version).
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/DataSenseResolver.java[lines=31..36]
----

Then, we need a method that retrieves the keys, which we will annotate with @MetaDataKeyRetriever:
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/DataSenseResolver.java[lines=40..49]
----

Now, we need a method that describes an entity given a keys, which we will annotate with @MetaDataRetriever, since we are using a static model, we can just create a PojoModel:
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/DataSenseResolver.java[lines=60..76]
----

Check the full link:{resourcesDir}/java/v5/DataSenseResolver.java[source code].

Now, in order to use this in our connector we need to modify our @Processors so that the user can pick the entities.

Lets annotate our @Connector class with the @MetaDataScope annotation. This will set the default MetaDataCategory that will be used every time the users chooses a @Processor that has a @MetaDataKeyParam.
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/CookBookConnector.java[lines=37..39]
----

In order to describe input and output, we need to tune our @Processor:
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/CookBookConnector.java[lines=71..77]
----

In our get operation we need to affect only output so we will modify it just a little:
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/CookBookConnector.java[lines=110..115]
----

Lets check our our new connector looks in studio.

Now, we have a combo that after we select the entity type and save it, will automatically refresh our MetaData.

image::datasense-static.png[width="900"]

And now even DataMapper knows how to interact with our @Connector

image::datasense-static2.png[width="900"]

View connector full source code link:{resourcesDir}/java/v5/CookBookConnector.java[here].

==== My model is dynamic

In our previous section we covered the scenario when your model is static. Lets take a look into a much more complex scenario.

There are APIs that provide a way to get entities definitions dynamically. Salesforce, NetSuite are just some examples of this.

In our case, our CookBook provides an operation that describes our entities, so lets use that instead to get the entities and structure.

Fist we need to get the supported entities, and generate a key that we can use later.
[source,java,indent=0]
----
include::{resourcesDir}/java/v6/DataSenseResolver.java[lines=47..59]
----

Now we need to use a structure that we can dynamically modify, and the way to do this in mule is by using a Map<String,Object> as parameters and return types of our connector.

Mule provides a builder that will help us in generate the MetaData for the entities.

[source,java,indent=0]
----
include::{resourcesDir}/java/v6/DataSenseResolver.java[lines=68..95]
----
Check the full link:{resourcesDir}/java/v6/DataSenseResolver.java[source code].

In our @Connector now we need to add the code to generate the entities from the Map, and return Map in all our operations. Why is this important? To maintain consistency in our API.

This is how our new Create looks like:
[source,java,indent=0]
----
include::{resourcesDir}/java/v6/CookBookConnector.java[lines=77..92]
----

Note that now the UI is different form before, since the input is not a map.

image::datamapper-ui.png[width="900"]

In our mule app, we can not update the metadata and use our connector, and as you can see not we have a map structure instead of a Pojo:

image::datamapper-map.png[width="900"]

==== Testing it

Lets start by adding an JUnit Test for our DataSenseResolver.

Since in this case we need to connect to the service and we want this test to be as similar as possible to what will actually happen when the users use our datasense in studio, lets get our list of keys using mule.

To do this we are going to write a test as we would for executing a flow, but instead of running on operation, we are going to ask to the mule context for our configuration element. This will actually give us an initialized connector. And after that we are going to ask for the keys and check that the result of this operation was a success.

Our config on the xml file can be something like:
[source,xml]
----
<cook-book:config-type username="admin" password="admin" name="config" doc:name="Cook-book"/>
----

And our test will look like:
[source,java,indent=0]
----
include::{resourcesDir}/java/v6/DataSenseTestCases.java[lines=17..19]
----

The same can be made for the MetaData itself. With our set of keys, we an ask our connector to describe the entity that corresponds to the first key.
[source,java,indent=0]
----
include::{resourcesDir}/java/v6/DataSenseTestCases.java[lines=20..21]
----

In studio we just need to configure our connector, and it will start fetching the keys.

After it finishes, we will be able to selected the entities in the UI.

image::datasense-dynamic.png[width="900"]

Note that on the XML the value written is the key.

image::datasense-dynamic-xml.png[width="900"]

After we add a datamapper in the middle we can see that the input and output is the one we described.

image::datasense-dynamic-datamapper.png[width="900"]

See:

* http://mulesoft.github.io/connector-certification-docs/current/user-manual.html#_datasense_dynamic_metadata[Testing Dynamic DataSense.]

Check the full link:{resourcesDir}/java/v6/DataSenseTestCases.java[source code].

=== Adding @Query

Use v2 and extend datasense to describe what can be querable.
