:mule: Mule Cookbook

== Adding DataSense

=== What is it?

DataSense improves the user experience at design time when creating Mule applications by enabling your connector to determine the API of your target resource.

Even though DataSense is optional, its use enables connector users acquire metadata of the entities in a service.

See:

* http://www.mulesoft.org/documentation/display/current/Adding+DataSense[Adding DataSense]
* http://www.mulesoft.org/documentation/display/current/DataSense[DataSense]

In this tutorial, we use a static DataSense model, which means that the entities are fixed and known, and do not change. The fields that this model supports are also fixed.

==== Using DataSense

To use DataSense in the cookbook:

. Analyze the entities in {mule} service. We just have two simple entities, Recipe and Ingredient that both extend from CookBookEntity.
. Look at how our createIngredient operation looks inside Anypoint Studio, and how it interacts with other components.
+
[source,java,indent=0]
----
include::{resourcesDir}/java/v3/CookBookConnector.java[lines=66..70]
----

===== Handling Ingredients

We defined the operation so that it receives an Ingredient, and it returns an Ingredient with the extra fields populated from the server.

Let's handle the ingredients:

. Check the input metadata to see that the expected output is a POJO, with the expected fields our Ingredient has:
+
image::datasense-expected-ingredients.png[width="600"]
+
. Verify that the output metadata is expected:
+
image::datasense-ingredients.png[width="600"]
+
. Drag and drop a DataMapper either behind or after our connector. The DataMapper automatically picks the input or output:
+
image::datasense-datamapper.png[title="DataMapper Receiving Connector Output", width="600"]
+
image::datamapper-output1.png[title="DataMapper Setting Connector Input",width="900"]
+
Because DevKit auto-generates static metadata, DevKit automatically ensures that your connector knows how to propagate metadata information.

===== Handling Recipes

We don't have just Ingredients, we also have Recipes, so we don't want one method for each entity we have in our model.

Let's modify our connector to just work with the CookBookEntity class:

. Create an operation:
+
[source,java,indent=0]
----
include::{resourcesDir}/java/v4/CookBookConnector.java[lines=67..72]
----
+
. Specify that the input can only be specified as a reference (due to a DevKit limitations on handling Abstract classes).
+
Let's see how this affects the UI and user experience.
+
Studio, can no longer determine input or output type:
+
image::ref-only-input.png[title="Connector Input with @RefOnly",width="900"]
+
image::ref-only-output.png[title="Connector Output with Abstract Class",width="900"]
+
Even if DataMapper is not automatically populated with the type:
+
image::ref-only-datamapper.png[title="DataMapper with connector with @RefOnly parameter",width="900"]
+
We are forced to manually configure the input:
+
image::manual-datamapper.png[title="Selecting a POJO manually",width="900"]

In the next section we get back our DataMapper-friendly user experience.

==== Implementing adding @MetaDataCategory

To implement DataSense using a @MetaDataCategory, you need to separate your implementation in two steps, retrieving the keys and describing the keys:

. Annotate our retriever with the @MetaDataCategory and inject the connector (this last one is a requirement in the current DevKit version):
+
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/DataSenseResolver.java[lines=31..36]
----
+
. We need a method that retrieves the keys, which we annotate with @MetaDataKeyRetriever:
+
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/DataSenseResolver.java[lines=40..49]
----
+
Describe an entity with its keys, which we annotate with @MetaDataRetriever. Because we use a static model, we can just create a POJO model:
+
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/DataSenseResolver.java[lines=60..76]
----
+
. Check the full link:{resourcesDir}/java/v5/DataSenseResolver.java[source code].
. To use this in our connector, modify our @Processors so that a user can pick the entities.
. Annotate our @Connector class with the @MetaDataScope annotation. This sets the default MetaDataCategory that's used every time users choose a @Processor that has a @MetaDataKeyParam.
+
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/CookBookConnector.java[lines=37..39]
----
+
. To describe input and output, tune your @Processor:
+
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/CookBookConnector.java[lines=71..77]
----
+
. In our get operation we need to affect only output so we modify it just a little:
+
[source,java,indent=0]
----
include::{resourcesDir}/java/v5/CookBookConnector.java[lines=110..115]
----
+
. Check our new connector looks in Studio. We have a combo after we select the entity type and save it. This automatically refreshes our metadata.
+
image::datasense-static.png[width="800"]
+
Now even DataMapper knows how to interact with our @Connector:
+
image::datasense-static2.png[width="800"]
+
. View connector full source code:
+
link:{resourcesDir}/java/v5/CookBookConnector.java[here].

==== Dynamic DataSense

In the previous section we covered the scenario when your model is static. Let's take a look into a much more complex scenario.

There are APIs that provide a way to get entities definitions dynamically. Salesforce, NetSuite are just some examples of this.

In our case, our Cookbook provides an operation that describes our entities, so let's use that instead to get the entities and structure:

. Get the supported entities, and generate a key that we can use later:
+
[source,java,indent=0]
----
include::{resourcesDir}/java/v6/DataSenseResolver.java[lines=47..59]
----
+
. Use a structure that we can dynamically modify, and the way to do this in Mule is by using a +Map<String,Object>+ as parameters and/or return types of our connector.
+
Mule provides a builder that helps us generate the MetaData for the entities.
+
[source,java,indent=0]
----
include::{resourcesDir}/java/v6/DataSenseResolver.java[lines=68..95]
----
+
. Check the full link:{resourcesDir}/java/v6/DataSenseResolver.java[source code].
+
. In our @Connector now we need to add the code to generate the entities from the Map, and return Map in all our operations. Why is this important? To maintain consistency in our API.
+
This is how our new Create looks like:
+
[source,java,indent=0]
----
include::{resourcesDir}/java/v6/CookBookConnector.java[lines=77..92]
----
+
Note that now the UI is a different form than before, because the input is not a map.
+
image::datamapper-ui.png[width="900"]
+
. In our Mule app, we cannot update the metadata and use our connector, and as you can see note that we have a map structure instead of a POJO:
+
image::datamapper-map.png[width="900"]

==== Testing DataSense

Let's add a JUnit Test for our DataSenseResolver.

Since in this case we need to connect to the service and we want this test to be as similar as possible to what actually happens when a user uses our DataSense in Studio, let's get our list of keys using Mule.

To do this we are going to write a test as we would for executing a flow, but instead of running an operation, we are going to ask for the Mule context for our configuration element. This gives us an initialized connector. After that we ask for the keys and check that the result of this operation was a success.

Our configuration on the XML file looks like:

[source,xml]
----
<cook-book:config-type username="admin" password="admin" name="config" doc:name="Cook-book"/>
----

Our test looks like:
[source,java,indent=0]
----
include::{resourcesDir}/java/v6/DataSenseTestCases.java[lines=17..19]
----

The same can be made for the metadata itself. With our set of keys, we can ask our connector to describe the entity that corresponds to the first key.

[source,java,indent=0]
----
include::{resourcesDir}/java/v6/DataSenseTestCases.java[lines=20..21]
----

In Studio, we need to configure our connector, and it starts fetching the keys.

After it finishes, we can select the entities in the UI.

image::datasense-dynamic.png[width="800"]

Note that on the XML the value written is the key.

image::datasense-dynamic-xml.png[width="800"]

After we add a DataMapper in the middle, we can see that the input and output is the one we described.

image::datasense-dynamic-datamapper.png[width="900"]

Check the full link:{resourcesDir}/java/v6/DataSenseTestCases.java[source code].

To go deeper into how to test DataSense check our http://mulesoft.github.io/connector-certification-docs/current/user-manual.html#_datasense_dynamic_metadata[Testing Dynamic DataSense] guide.

// TODO
// === Adding @Query
